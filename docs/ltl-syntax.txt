-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | parser, printer and generator for LTL formulae
--   
--   parser, printer and generator for LTL formulae
@package ltl-syntax
@version 0.1.0.1


-- | Abstract representation of LTL Formulae
module Language.LTL.Data

-- | unary operators
data UnOp
Neg :: UnOp
F :: UnOp
G :: UnOp
X :: UnOp

-- | binary operators
data BinOp
Or :: BinOp
And :: BinOp
U :: BinOp

-- | type for LTL formulae
--   
--   abstract representation of ! (X ((F (a | b)) U (1 &amp; (G c))) )
--   
--   <pre>
--   Unary Neg $
--     Unary X $ 
--       Binary U 
--         (Unary F $ 
--           Binary Or (AP "a") (AP "b") ) 
--         (Binary And 
--           (Nullary True) 
--           (Unary G $ AP "c"))
--   </pre>
data Formula
AP :: Text -> Formula
Nullary :: Bool -> Formula
Unary :: UnOp -> Formula -> Formula
Binary :: BinOp -> Formula -> Formula -> Formula
newtype SpinNullary
SpinNullary :: Bool -> SpinNullary
newtype SpinUnOp
SpinUnOp :: UnOp -> SpinUnOp
newtype SpinBinOp
SpinBinOp :: BinOp -> SpinBinOp

-- | type for LTL formulae to be printed in spin's format
newtype SpinFormula
SpinFormula :: Formula -> SpinFormula

-- | represents the positions in the syntax tree of a LTL formula
type Pos = [Int]
instance GHC.Show.Show Language.LTL.Data.SpinFormula
instance GHC.Classes.Ord Language.LTL.Data.SpinFormula
instance GHC.Classes.Eq Language.LTL.Data.SpinFormula
instance GHC.Show.Show Language.LTL.Data.Formula
instance GHC.Classes.Ord Language.LTL.Data.Formula
instance GHC.Classes.Eq Language.LTL.Data.Formula
instance GHC.Show.Show Language.LTL.Data.BinOp
instance GHC.Enum.Bounded Language.LTL.Data.BinOp
instance GHC.Enum.Enum Language.LTL.Data.BinOp
instance GHC.Classes.Ord Language.LTL.Data.BinOp
instance GHC.Classes.Eq Language.LTL.Data.BinOp
instance GHC.Show.Show Language.LTL.Data.UnOp
instance GHC.Enum.Bounded Language.LTL.Data.UnOp
instance GHC.Enum.Enum Language.LTL.Data.UnOp
instance GHC.Classes.Ord Language.LTL.Data.UnOp
instance GHC.Classes.Eq Language.LTL.Data.UnOp


-- | A parser for LTL formulae in spot's format.
module Language.LTL.Parser

-- | the parser of one LTL formula in spot's format
--   
--   <pre>
--   &gt;&gt;&gt; parse "(p) U (G q)"
--   Right (Binary U (AP "p") (Unary G (AP "q")))
--   </pre>
parse :: Text -> Either String Formula

-- | expression parser for LTL formulae
formula :: Parser Formula

-- | parser for nullary operators, atomic propositions and formulae
--   enclosed in parentheses
--   
--   <pre>
--   &gt;&gt;&gt; parseOnly atomic "(p1)"
--   Right (AP "p1")
--   </pre>
atomic :: Parser Formula

-- | parser for names of atomic propositions, removing withespace after it
--   
--   <pre>
--   &gt;&gt;&gt; parseOnly identifier "p1   "
--   Right "p1"
--   </pre>
identifier :: Parser Text

-- | parser for things enclosed in some strings
--   
--   <pre>
--   &gt;&gt;&gt; parseOnly (embracedBy identifier "[" "]") "[ p1  ]"
--   Right "p1"
--   </pre>
embracedBy :: Parser a -> Text -> Text -> Parser a

-- | parser for formulae enclosed in parentheses
--   
--   <pre>
--   parens p = embracedBy p "(" ")"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseOnly (parens atomic) "((p1))"
--   Right (AP "p1")
--   </pre>
parens :: Parser a -> Parser a

-- | parser for tokens, removing all withespace after it
token :: Text -> Parser ()
whitespace :: Parser ()


-- | A printer of LTL formulae into spot's and spin's format.
module Language.LTL.Printer

-- | printer of LTL formulae in spot's and spin's format
--   
--   <pre>
--   &gt;&gt;&gt; toText $ (Binary U (AP "p") (Unary G (AP "q")))
--   "(p U (G q))"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toText $ SpinFormula  (Binary U (AP "p") (Unary G (AP "q")))
--   "(p U ([] q))"
--   </pre>
class ToText a
toText :: ToText a => a -> Text
instance Language.LTL.Printer.ToText GHC.Types.Bool
instance Language.LTL.Printer.ToText Language.LTL.Data.UnOp
instance Language.LTL.Printer.ToText Language.LTL.Data.BinOp
instance Language.LTL.Printer.ToText Language.LTL.Data.Formula
instance Language.LTL.Printer.ToText Language.LTL.Data.SpinNullary
instance Language.LTL.Printer.ToText Language.LTL.Data.SpinUnOp
instance Language.LTL.Printer.ToText Language.LTL.Data.SpinBinOp
instance Language.LTL.Printer.ToText Language.LTL.Data.SpinFormula


-- | Manipulating LTL formulae.
module Language.LTL.Ops

-- | decompose formula into subformulae
children :: Formula -> [(Formula -> Formula, Formula)]

-- | compute positions in the syntax tree of a formula
--   
--   <pre>
--   &gt;&gt;&gt; pos $ Binary U (AP "p") (Unary G (AP "q"))
--   [[],[0],[1],[1,0]]
--   </pre>
pos :: Formula -> [Pos]

-- | compute positions and subformulae at these positions
--   
--   <pre>
--   &gt;&gt;&gt; possubs $ Binary U (AP "p") (Unary G (AP "q"))
--   [ ([],Binary U (AP "p") (Unary G (AP "q")))
--   , ([0],AP "p")
--   , ([1],Unary G (AP "q"))
--   , ([1,0],AP "q")
--   ]
--   </pre>
possubs :: Formula -> [(Pos, Formula)]

-- | postions where an atomic proposition is in a formula
--   
--   <pre>
--   &gt;&gt;&gt; appos $ Binary U (AP "p") (Unary G (AP "q"))
--   [[0],[1,0]]
--   </pre>
appos :: Formula -> [Pos]

-- | compute subformula at position
--   
--   <pre>
--   &gt;&gt;&gt; peek (Binary U (AP "p") (Unary G (AP "q"))) [1]
--   Unary G (AP "q")
--   </pre>
peek :: Formula -> Pos -> Formula

-- | replace the subformula at the position with another formula
--   
--   <pre>
--   &gt;&gt;&gt; poke (Binary U (AP "p") (Unary G (AP "q"))) ([1],AP "p")
--   Binary U (AP "p") (AP "p")
--   </pre>
poke :: Formula -> (Pos, Formula) -> Formula

-- | replace multiple subformulae
--   
--   <pre>
--   pokes = foldl poke
--   </pre>
pokes :: Formula -> [(Pos, Formula)] -> Formula


-- | A generator for LTL formulae. Random formulae of a given size can be
--   computed and all formulae of this size can be enumerated. Some
--   patterns are also implemented.
module Language.LTL.Gen

-- | typeclass for different selections of a list: pick one randomly (in IO
--   monad), or select all (in list monad)
--   
--   an instance (selector) represents a set of elements
--   
--   <pre>
--   &gt;&gt;&gt; select [Neg, F, G, X]) :: IO UnOp
--   F
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (select [Neg, F, G, X]) :: [UnOp]
--   [Neg,F,G,X]
--   </pre>
class Monad m => Select (m :: * -> *)
select :: Select m => [t] -> m t

-- | represents a collection of sets indexed by numbers
--   
--   Here a set indexed by s contains elements of size s.
type Gen m a = Int -> m a

-- | a generator for unary operators
--   
--   <pre>
--   &gt;&gt;&gt; (gen_unop 2) :: IO [UnOp]
--   [G,F]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (gen_unop 2) :: [[UnOp]]
--   [ [Neg,Neg],[Neg,F],[Neg,G],[Neg,X]
--   , [F,Neg],[F,F],[F,G],[F,X]
--   , [G,Neg],[G,F],[G,G],[G,X]
--   , [X,Neg],[X,F],[X,G],[X,X]
--   ]
--   </pre>
gen_unop :: Select m => Gen m [UnOp]

-- | a generator for binary operators
gen_binop :: Select m => Gen m [BinOp]

-- | cross product of collections represented by generators where the sizes
--   of the componentes are added
--   
--   <pre>
--   &gt;&gt;&gt; times gen_unop gen_binop 3
--   ([X],[U,And])
--   </pre>
times :: Select m => Gen m a -> Gen m b -> Gen m (a, b)

-- | unions of sets represented by selectors
--   
--   <pre>
--   &gt;&gt;&gt; unions  [gen_unop 1, gen_unop 2] :: IO [UnOp ]
--   [G]
--   </pre>
unions :: Select m => [m a] -> m a

-- | select formula of given size beginning with an unary operator s.th.
--   neither F F, G G or Neg Neg occur
--   
--   the allowed binary and unary operators and the atomic propositions are
--   given
forms_unary :: Select m => [BinOp] -> [UnOp] -> [Text] -> Gen m Formula

-- | select a formula of a given size
--   
--   the allowed binary and unary operators and the atomic propositions are
--   given
--   
--   <pre>
--   &gt;&gt;&gt; forms [And, Or, U] [F, G, X, Neg] ["p0","p1"] 3
--   Unary G (Unary F (AP "p1"))
--   </pre>
forms :: Select m => [BinOp] -> [UnOp] -> [Text] -> Gen m Formula

-- | select a formula of a given size where the atomic propositions are
--   numbered increasingly
--   
--   a generator for formulae and the maximal number of atomic propositions
--   used are given (if the number of atomic propositions is at least as
--   large as the desired size we obtain all formulae of this size when
--   enumerating)
--   
--   <pre>
--   &gt;&gt;&gt; forms_nf (forms [And,Or,U] [F,G,X,Neg]) 5 15
--   Unary Neg 
--     (Binary U 
--       (Unary Neg 
--         (Binary And 
--           (Binary U   (Unary X (AP "p0"))   (AP "p0")) 
--           (Binary U 
--             (Unary G (Unary X (AP "p1"))) 
--             (Unary X (AP "p2"))
--           )
--         )			
--       ) 
--       (AP "p3")
--     )
--   </pre>
forms_nf :: Select m => ([Text] -> Gen m Formula) -> Int -> Gen m Formula

-- | generate a given number of atomic propositions that are numbered
--   increasingly z_i &lt;= 1 + max { z1,..., z_(i-1) }
--   
--   <pre>
--   &gt;&gt;&gt; aps_gen 3 [] [1, 2, 3, 4]
--   [1,2,1]
--   </pre>
aps_gen :: (Select m, Eq a) => Int -> [a] -> [a] -> m [a]

-- | select formulae where the operators are chosen uniformely
--   
--   <pre>
--   forms_uniform_nf = forms_nf (forms [minBound..maxBound][minBound..maxBound])
--   </pre>
forms_uniform_nf :: Select m => Int -> Gen m Formula

-- | seleft formulae of the F,G fragment of LTL (only the temporal
--   operators F and G are allowed)
--   
--   <pre>
--   forms_fg_nf = forms_nf (forms ([minBound..maxBound] L.\\ [U]) [F,G,Neg])
--   </pre>
--   
--   Generate a random formula of size 3 with at most 2 atomic
--   propositions:
--   
--   <pre>
--   &gt;&gt;&gt; (forms_fg_nf 2 3) :: IO Formula
--   Unary G (Unary F (AP "p0"))
--   </pre>
--   
--   Generate all formulae of size 3 with at most 2 atomic propositions:
--   
--   <pre>
--   &gt;&gt;&gt; (forms_fg_nf 2 3) :: [Formula]
--   [Binary Or (AP "p0") (AP "p1")
--   ,Binary Or (AP "p0") (AP "p0")
--   ,Binary And (AP "p0") (AP "p1")
--   ,Binary And (AP "p0") (AP "p0")
--   ,Unary G (Unary F (AP "p0"))
--   ,Unary Neg (Unary F (AP "p0"))
--   ,Unary F (Unary G (AP "p0"))
--   ,Unary Neg (Unary G (AP "p0"))
--   ,Unary F (Unary Neg (AP "p0"))
--   ,Unary G (Unary Neg (AP "p0"))
--   ]
--   </pre>
forms_fg_nf :: Select m => Int -> Gen m Formula

-- | select formulae where the operators F and G occur with higher
--   probability
--   
--   <pre>
--   forms_morefg_nf = forms_nf (forms [minBound..maxBound] ([minBound..maxBound]++[F,G]))
--   </pre>
forms_morefg_nf :: Select m => Int -> Gen m Formula
c1 :: Int -> Formula
c2 :: Int -> Formula
e :: Int -> Formula
q :: Int -> Formula
r :: Int -> Formula
s :: Int -> Formula
u :: Int -> Formula
u2 :: Int -> Formula
f :: Int -> Formula
instance Language.LTL.Gen.Select []
instance Language.LTL.Gen.Select GHC.Types.IO


module Language.LTL.Property

-- | the size of a formula
--   
--   <pre>
--   &gt;&gt;&gt; size $ Binary U (AP "p") (Unary G (AP "q"))
--   4
--   </pre>
size :: Formula -> Int

-- | is the first operator not a negation ?
--   
--   <pre>
--   &gt;&gt;&gt; nonnegative $ Binary U (AP "p") (Unary G (AP "q"))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nonnegative $ Unary Neg $ Binary U (AP "p") (Unary G (AP "q"))
--   False
--   </pre>
nonnegative :: Formula -> Bool


-- | A library for LTL formulae. Contains a parser and printer to spot's
--   and spin's format and a generator for LTL formulae that can generate
--   random forumlae of a given size and enumerate formulae of a given
--   size.
module Language.LTL

-- | type for LTL formulae
--   
--   abstract representation of ! (X ((F (a | b)) U (1 &amp; (G c))) )
--   
--   <pre>
--   Unary Neg $
--     Unary X $ 
--       Binary U 
--         (Unary F $ 
--           Binary Or (AP "a") (AP "b") ) 
--         (Binary And 
--           (Nullary True) 
--           (Unary G $ AP "c"))
--   </pre>
data Formula
AP :: Text -> Formula
Nullary :: Bool -> Formula
Unary :: UnOp -> Formula -> Formula
Binary :: BinOp -> Formula -> Formula -> Formula

-- | type for LTL formulae to be printed in spin's format
newtype SpinFormula
SpinFormula :: Formula -> SpinFormula

-- | the parser of one LTL formula in spot's format
--   
--   <pre>
--   &gt;&gt;&gt; parse "(p) U (G q)"
--   Right (Binary U (AP "p") (Unary G (AP "q")))
--   </pre>
parse :: Text -> Either String Formula

-- | printer of LTL formulae in spot's and spin's format
--   
--   <pre>
--   &gt;&gt;&gt; toText $ (Binary U (AP "p") (Unary G (AP "q")))
--   "(p U (G q))"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toText $ SpinFormula  (Binary U (AP "p") (Unary G (AP "q")))
--   "(p U ([] q))"
--   </pre>
class ToText a
toText :: ToText a => a -> Text

-- | select a formula of a given size
--   
--   the allowed binary and unary operators and the atomic propositions are
--   given
--   
--   <pre>
--   &gt;&gt;&gt; forms [And, Or, U] [F, G, X, Neg] ["p0","p1"] 3
--   Unary G (Unary F (AP "p1"))
--   </pre>
forms :: Select m => [BinOp] -> [UnOp] -> [Text] -> Gen m Formula

-- | select a formula of a given size where the atomic propositions are
--   numbered increasingly
--   
--   a generator for formulae and the maximal number of atomic propositions
--   used are given (if the number of atomic propositions is at least as
--   large as the desired size we obtain all formulae of this size when
--   enumerating)
--   
--   <pre>
--   &gt;&gt;&gt; forms_nf (forms [And,Or,U] [F,G,X,Neg]) 5 15
--   Unary Neg 
--     (Binary U 
--       (Unary Neg 
--         (Binary And 
--           (Binary U   (Unary X (AP "p0"))   (AP "p0")) 
--           (Binary U 
--             (Unary G (Unary X (AP "p1"))) 
--             (Unary X (AP "p2"))
--           )
--         )			
--       ) 
--       (AP "p3")
--     )
--   </pre>
forms_nf :: Select m => ([Text] -> Gen m Formula) -> Int -> Gen m Formula
select :: Select m => [t] -> m t

-- | select formulae where the operators are chosen uniformely
--   
--   <pre>
--   forms_uniform_nf = forms_nf (forms [minBound..maxBound][minBound..maxBound])
--   </pre>
forms_uniform_nf :: Select m => Int -> Gen m Formula

-- | seleft formulae of the F,G fragment of LTL (only the temporal
--   operators F and G are allowed)
--   
--   <pre>
--   forms_fg_nf = forms_nf (forms ([minBound..maxBound] L.\\ [U]) [F,G,Neg])
--   </pre>
--   
--   Generate a random formula of size 3 with at most 2 atomic
--   propositions:
--   
--   <pre>
--   &gt;&gt;&gt; (forms_fg_nf 2 3) :: IO Formula
--   Unary G (Unary F (AP "p0"))
--   </pre>
--   
--   Generate all formulae of size 3 with at most 2 atomic propositions:
--   
--   <pre>
--   &gt;&gt;&gt; (forms_fg_nf 2 3) :: [Formula]
--   [Binary Or (AP "p0") (AP "p1")
--   ,Binary Or (AP "p0") (AP "p0")
--   ,Binary And (AP "p0") (AP "p1")
--   ,Binary And (AP "p0") (AP "p0")
--   ,Unary G (Unary F (AP "p0"))
--   ,Unary Neg (Unary F (AP "p0"))
--   ,Unary F (Unary G (AP "p0"))
--   ,Unary Neg (Unary G (AP "p0"))
--   ,Unary F (Unary Neg (AP "p0"))
--   ,Unary G (Unary Neg (AP "p0"))
--   ]
--   </pre>
forms_fg_nf :: Select m => Int -> Gen m Formula

-- | select formulae where the operators F and G occur with higher
--   probability
--   
--   <pre>
--   forms_morefg_nf = forms_nf (forms [minBound..maxBound] ([minBound..maxBound]++[F,G]))
--   </pre>
forms_morefg_nf :: Select m => Int -> Gen m Formula
e :: Int -> Formula
u :: Int -> Formula
u2 :: Int -> Formula
r :: Int -> Formula
c1 :: Int -> Formula
c2 :: Int -> Formula
q :: Int -> Formula
s :: Int -> Formula
f :: Int -> Formula
